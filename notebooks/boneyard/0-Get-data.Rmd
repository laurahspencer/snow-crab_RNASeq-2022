---
title: "Get-data"
author: "Laura H Spencer"
date: "10/25/2023"
output: html_document
---

In this notebook I import gene-level counts from snow crab RNA-Seq data. Trimmed RNASeq reads were aligned to the tanner crab genome using the STAR aligner, and counts (i.e. the number of reads aligning to each gene) were determined during alignment by STAR using the tanner annotation file. NOTE: before the alignment I converted the .gff annotation file (final_annotation.gff) to a .gtf file (final_annotation_LHS.gtf) for STAR.  

### Load R packages needed for this notebook 

```{r message=FALSE, warning=FALSE, results=FALSE}
list.of.packages <- c("tidyverse", "reshape2", "here", "plotly", "purrr", "janitor", "readxl", "clipr") #add new libraries here 

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# Load all libraries 
lapply(list.of.packages, FUN = function(X) {
  do.call("require", list(X)) 
})
```

## Read in gene count data 

### Generate tab-separated file that lists data file names (one file for each library) and sample number

NOTE: this code chunk uses the bash language, not R

```{bash}
rm ../results/star/countsfilenames.txt
for file in ../results/star/*.ReadsPerGene.out.tab
do
filename="$(echo $file)"
sample="$(basename -a $filename | cut -d "." -f 1)"
printf "%s\t%s\n" "$filename" "$sample" >> ../results/star/countsfilenames.txt
done
```

### Preview the contents of the countsfilenames.txt file 

```{bash}
head -n 5 ../results/star/countsfilenames.txt
```

### Generate object with filenames and sample annotation information, then join 

```{r}
# Create object from the countsfilenames.txt file 
filenames <- read_delim(file="../results/star/countsfilenames.txt", delim = "\t", col_names = c("filename", "sample")) %>%
  mutate(sampleID=paste("S", sample, sep=""))
files <- file.path(filenames$filename) #extract vector of filenames 
all(file.exists(files)) #easy code to check that all files exist! 

# Create sample.info object with annotation name for each sample/file, this will be used throughout the analysis  
sample.info <- read_excel("../data/Crabs for RNA analysis.xlsx", sheet = "Sheet1", 
                          skip = 8, col_names = c("sample", "pH", "duration"), na = "N/A") %>% 
          mutate_at(vars(pH, duration), as.factor) %>%
  mutate(OA=as.factor(case_when(
    pH=="pH 7.5" ~ "severe",
    pH=="pH 7.8" ~ "moderate",
    pH=="Ambient" ~ "ambient"))) %>%
  mutate(treatment=as.factor(case_when(
    (OA=="severe" & duration=="long") ~ "severe_long",
    (OA=="severe" & duration=="short") ~ "severe_short",
    (OA=="moderate" & duration=="long") ~ "moderate_long",
    (OA=="moderate" & duration=="short") ~ "moderate_short",
    TRUE ~ "ambient"))) %>%
  left_join(filenames)
```

### Import count data into list of dataframes (one for each library)

selecting only the first 2 columns (1=gene ID, 2=count); rename columns 

```{r}
file_list <- vector(mode = "list", length = nrow(filenames))
names(file_list) <- c(filenames$sampleID)

# Check out number of counts & number of genes for each sammple 
for (i in 1:nrow(filenames)) {
    file_list[[i]] <- data.frame(read.delim(file=files[i], header = F))[-1:-4,1:2]
    names(file_list[[i]]) <- c("gene", filenames$sampleID[i])
    print(paste("Total COUNTS,", names(file_list[[i]][2]), ":", prettyNum(sum(file_list[[i]][2]), big.mark=","), sep=" "))
    print(paste("Total GENES,", names(file_list[[i]][2]), ":", prettyNum(nrow(file_list[[i]] %>% filter(.[[2]] != 0)), big.mark=","), sep=" "))
}
```

### Preview counts for one sample to see what gene count data looks like 

```{r}
file_list[[1]] %>% head(n=20)
```

### Merge data from all samples into one dataframe 

```{r}
counts <- file_list %>% purrr::reduce(full_join, by = "gene") %>% column_to_rownames(var="gene")
head(counts) #resulting dataframe has genes by row, and samples by column
```

## Summarize counts and visualize

```{r}
print(paste("Number of samples:", ncol(counts), sep=" "))
print(paste("Total number of genes in dataframe:", prettyNum(nrow(counts), big.mark = ","), sep=" "))
print(paste("Average number of genes per sample:", prettyNum(mean(colSums(counts != 0)), big.mark = ","), sep=" "))
print(paste("Total counts, all samples:", prettyNum(sum(colSums(counts)), big.mark = ","), sep=" "))
#print(paste("Counts for", colnames(counts %>% select(contains("Tank"))), ":",  prettyNum(colSums(counts %>% select(contains("Tank"))), big.mark = ","), sep=" "))


#inspect total counts by sample - this generates an interactive plot, hover over bars to identify sample 
 ggplotly(
   ggplot(data.frame(colSums(counts)) %>% 
            dplyr::rename(count.total = 1) %>% rownames_to_column(var="sample")) + 
     geom_bar(aes(x=sample, y=count.total), stat = "identity") + ggtitle("Total count by sample") + 
              theme(axis.text.x = element_blank(), axis.ticks.x = element_blank())) 
```

## Filter dataset 

### Remove entire sample(s) from dataset if needed (OPTIONAL - comment out of not needed)

Sample 45 has very few counts, remove 

```{r}
remove.list <- c("S45")
counts <- counts[ , -which(names(counts) %in% remove.list)]
sample.info <- sample.info[ -which(sample.info$sampleID %in% remove.list), ]

# resave sample info object
save(sample.info, file="../data/sample.info")

nrow(sample.info) == ncol(counts) #should = TRUE if sample.info and gene count matrix countain the same samples 
```

### Transpose dataframe so each row = a sample, and each column = genes

```{r}
counts.t <- as.data.frame(t(counts))  
```

### Remove low-frequency genes from dataset (optional, but suggested) 

Here we remove genes (rows) that are expressed at very low levels. These are not likely to be biologically relevant and by reducing the number of genes to be assessed for differential expression we reduce the impact of the multiple-comparison correction. The definition of "low-frequency genes" can be adjusted - there's no hard and fast rule - but this is what I have been using: "Genes with mean count <10 across all samples or those with counts <30 across at minimum 10% of the samples were discarded." You'll see that while many genes were discarded (~36,000 were dropped, out of ~47,500), the vast majority of fragments were retained (99.955%)! This is because those 36k genes only had a few reads aligning to them. 

```{r}
keep1 <- colMeans(counts.t, na.rm=TRUE) >= 10 #identify genes with mean count >= 10 across all samples (excluding NAs = 10)
keep2 <- rowSums( counts >= 10 ) >= 0.1*43 #identify genes with counts>=10 across at minimum 10% of the samples
keep <- unique(c(names(which(keep1 == T)), names(which(keep2 == T)))) # list of genes meeting one of the two above criteria
counts.ts <- counts.t[,keep]

# Print summary of gene filtering. 
print(paste("# genes before filtering:", ncol(counts.t)))
print(paste("# genes remaining after pre-filtering:", ncol(counts.ts)))
print(paste("# of genes dropped:", ncol(counts.t) - ncol(counts.ts), sep=" "))
print(paste("% of fragments remaining after pre-filtering: ", signif(100*sum(counts.ts, na.rm = T)/sum(counts.t, na.rm = T), digits = 5), "%", sep=""))
print(paste("Number of fragments dropped: ", signif(sum(counts.t, na.rm = T)-sum(counts.ts, na.rm = T), digits = 5)))
print(paste("% of fragments dropped: ", signif(100*(sum(counts.t, na.rm = T)-sum(counts.ts, na.rm = T))/sum(counts.t, na.rm = T), digits = 5), "%", sep=""))
print(paste("Number of fragments remaining: ", signif(sum(counts.ts, na.rm = T), digits = 5)))
```

### Save counts file, and transformed counts file - to be used in analyses! 

```{r}
save(counts, file = "../results/counts")
save(counts.t, file = "../results/counts.t")
save(counts.ts, file = "../results/counts.ts")
```

## Generate annotation objects 

Many of the enrichment analyses I run require Uniprot IDs for each gene.  Not all annotation files for genomes (or transcriptomes) have Uniprot ID's associated with each gene. So, to get these ID's I run a program called Blast to match the sequences of known genes in the reference genome to sequences in the Uniprot/Swissprot database. Blast is run on Sedna or Mox and takes a while (hours to days, depending on the number/size of gene sequences). Before doing that, though, I need to create a .bed file which identifies the location of each gene in the genome. Once I create a bed file listing genes, I will use that with `getfasta` from `bedtools` (another bash language program) to extract gene sequences, which I will then use with blast to identify gene function

### Generate .bed file of genes for Blasting against Uniprot/Swissprot

NOTE: GFF format use a 1-based coordinate system, while BED format uses a 0-based coordinate system. I therefore need to convert my coordinates. Check out this helpful [coordinate system summary](https://tidyomics.com/blog/2018/12/09/2018-12-09-the-devil-0-and-1-coordinate-system-in-genomics/). 

```{r}
read.delim(file = "../references/final_annotation.gff", sep = "", header = F) %>%
  mutate(V3=as.factor(V3)) %>% filter(V3=="gene") %>%
  select(V1, V4, V5, V9) %>%
  mutate(V4=as.numeric(V4), V5=as.numeric(V5)) %>%
  mutate(V4=V4-1) %>% #convert from 1-based to 0-based by subtracting 1 from the start position
  mutate(ID=str_extract(V9, "ID=(.*?);")) %>%
  mutate(ID=str_remove(ID, ";")) %>% mutate(ID=str_remove(ID, "ID=")) %>%
  select(V1,V4,V5,ID) %>%
  write.table(., "../references/tanner_genes.bed", sep = "\t",
              col.names = F, row.names = F, quote = F)
```

### Check out resulting .bed file. 
This has 4 columns: 1. Chromosome/contig ID (on tanner genome), 2. Gene start locus 3. Gene end locus, 4. Gene ID

```{bash}
head ../references/tanner_genes.bed
```

### Run `blast` on Sedna/Mox to annotate genes. 

Used the script [blast-tanner.sh](../scripts/blast-tanner.sh), which needs the following inputs:   
  1. The most current Uniprot/Swissprot database, which can be downloaded from https://www.uniprot.org/help/downloads. Select the "Reviewed (Swiss-Prot)" in fasta format.   
  2. The genome fasta file that was used for aligning reads. E.g. the tanner fasta was tanner.asm.hic.p_ctg.fa.  Before blasting, the script uses `bedtools getfasta` to grab the sequences for each gene from the genome. It's critical that the annotation file (.gff) that was used in the previous step to generate the .bed file is associated with the same genome file!   
  3. The programs `blast` and `bedtools` need to be installed and loaded (the above script shows how they can be loaded on Mox)  
  
Once the blast results have finished, proceed to next step! 

### Import Tanner genome annotation blast results (Uniprot/Swissprot annotated genes)

NOTE: To run the below code you'll need the file tanner_genes_blastx.tab. It's very large, so grab it from [Google Drive](https://drive.google.com/file/d/1WJVAXghnyp7sZngyDdt5oDt3NokEjlas/view?usp=drive_link) and save to the snowcrab/references/ directory. 

blastx output format 6 is tab file with the following columns:  
1. qaccver = Query accesion.version  
2. saccver = Subject accession.version  
3. pident = Percentage of identical matches  
4. length = Alignment length  
5. mismatch = Number of mismatches  
6. gapopen = Number of gap openings  
7. qstart = Start of alignment in query  
8. qend = End of alignment in query  
9. sstart =  Start of alignment in subject  
10. send = End of alignment in subject  
11. evalue =  Expect value  
12. bitscore = Bit score  

```{r}
tanner.blast <- 
  read_delim(file = "../references/tanner_genes_blastx.tab", delim = "\t", 
                           col_names = c("qaccver", "saccver", "pident", "length", "mismatch", "gapopen", "qstart", "qend", "sstart", "send", "evalue", "bitscore")) %>%
  separate(qaccver, sep = ":|-", into = c("SeqID","Start","End")) %>%
  mutate_at(vars(Start, End), as.numeric) %>%
  separate(saccver, sep="\\|", into=c("na", "SPID", "gene.Uni"), remove = F) %>%
  dplyr::select(-na) %>% separate(gene.Uni, sep="_", into=c("gene.Uni", "species"), remove=T) %>%
  group_by(SeqID, Start, End) %>% dplyr::slice(which.min(evalue))  %>% # where multiple blast hits for same gene, select one with minimum e-value
  left_join(., read_delim(file="../references/tanner_genes.bed", delim="\t", col_names = c("SeqID", "Start", "End", "GeneID"))) %>%
  dplyr::select(GeneID, everything()) %>%
  clean_names()
  
# E-VALUE FILTERING
# Count annotated genes with e-value filters
tanner.blast %>% filter(evalue < 1.0e-10) %>% nrow() # 12,993 genes have e-value <1e-10
tanner.blast %>% filter(evalue < 1.0e-15) %>% nrow() # 9,979 genes have e-value <1e-15
tanner.blast %>% filter(evalue < 1.0e-20) %>% nrow() # 7,252 genes have e-value <1e-20

# Filter blast results to meet desired e-value threshold - here we choose 1e-10
tanner.blast <- tanner.blast %>% filter(evalue < 1.0e-10)

save(tanner.blast, file = "../references/tanner.blast")
load(file = "../references/tanner.blast")
```

### Annotate with Gene Ontology (GO) terms and other info

NOTE:  I needed GO IDs and gene functions, which weren't included in the blast file.  So I copied the column containing all Uniprot IDs from the blast object, then pasted those into the tool Uniprot batch retrieval tool (https://www.uniprot.org/uploadlists/), and selected the columns: Entry, Entry name, Protein names, Gene names, Organism, Gene ontology (biological process), Gene ontology (cellular componenet), Gene ontology (molecular processes), Gene ontology (GO), Gene ontology Ids. I then downloaded all entries to a tab file, saved as: /references/tanner_genes_GO.tsv. Now I'll read that into R and join with the tanner.blast dataframe to link GO IDs with genes for exploration and enrichment analyses. 

```{r}
# Use this code to get list of Uniprot SPID (gene identifiers) to input into the Uniprot Batch Retrieval tool, to obtain GO terms for each gene
tanner.blast %>% ungroup() %>% dplyr::select(spid) %>% distinct() %>%
  na.omit() %>% unlist() %>% as.vector() %>% write_clip(allow_non_interactive = TRUE)

# After downloading the tanner_genes_GO.tsv file, add GO terms to Uniprot annotation object
tanner.blast.GO <- left_join(tanner.blast, read_delim(file = "../references/tanner_genes_GO.tsv", 
                                                      delim = "\t") %>% clean_names(),
                             by = c("spid"="entry")) %>% ungroup()

save(tanner.blast.GO, file = "../references/tanner.blast.GO")
#load(file = "../references/tanner.blast.GO")

# Preview annotated list of genes with their Gene Ontology information, which describes the various functions performed by each gene
head(tanner.blast.GO)
```

### Annotate gene counts dataframe

Add gene name and functional information to each gene in our snow crab dataset! 

```{r}
counts.annot.tanner <- right_join(
  tanner.blast %>% ungroup() %>% dplyr::select(gene_id, spid, gene_uni, species, pident, evalue, gene_id, seq_id, start, end, gene_id),
  counts.ts %>% t() %>% as.data.frame() %>% rownames_to_column("gene_id"), "gene_id") %>%
  left_join(tanner.blast.GO %>% dplyr::select(gene_id, protein_names, gene_names), "gene_id") 

save(counts.annot.tanner, file = "../results/counts.annot.tanner")
#load(file = "../results/counts.annot.tanner")
write.csv(counts.annot.tanner, file = "../results/counts.annot.tanner.csv", row.names = F, quote = F) #save annotated gene information to .csv file
```

#### How many of our analyzed genes are annotated? Answer: 5,808 (out of 11,491 genes that we will analyze)

```{r}
right_join(
  tanner.blast %>% ungroup() %>% dplyr::select(gene_id, spid, gene_uni, species, pident, evalue),
  counts.ts %>% t() %>% as.data.frame() %>% rownames_to_column(var = "gene_id"), "gene_id") %>% filter(!is.na(spid)) %>%
  nrow()
```

#### Here's the total number of genes in the tanner gff: 47,449 genes

```{r}
read_delim(file = "../references/final_annotation.gff", delim = "\t", col_names = F, skip = 8) %>% 
  mutate(X3=as.factor(X3)) %>% filter(X3=="gene") %>% nrow()
```

